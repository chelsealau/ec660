Design Decisions
Eviction Policy


The most significant design decision that was made was the page eviction policy implemented in the evictPage() method in BufferPool.java. We chose to generate a random number between 0 and the number of pages in the buffer pool. All keys (pids) in the buffer pool were inserted into a list, and the random generated number was used to select the key (pid) and its corresponding page to be evicted. Other than this decision there were no other significant design decisions since skeleton methods were being populated.


Insertion and Deletion
Splitting leaf nodes was much simpler than splitting internal pages as there aren’t as many pointers to keep track of and the positioning of nodes. For Leaf Pages, it was as simple as dividing the number of tuples in half and distributing them among the two new pages using the reverseIterator. Once this was done, it was a matter of checking for an existing right page and updating the sibling pointers respectively.


For the internal pages, the process was similar, however, we needed to adjust for even and odd number of entries as this effected an even split for the nodes. Otherwise, the process was identical to the leaf node splitting without the sibling pointer updates.
Changes to API
No changes were made to the API. 
Missing/Incomplete Elements of Code


There are no missing/incomplete elements of code besides the skeleton methods that were not required for this lab. BTreeFile.stealFromLeafPage() and BTreeFile.mergeLeafPages()(the bonus questions) were not implemented.


While there is no missing code, unfortunately, the implementation of splitInternalPage is not 100% functional on the systemtests. Small bugs evaded a solution this time.
Length Project Took and Difficulties 
We worked on this project for approximately 1 week, but there were no parts we found particularly difficult or confusing for this set of tasks, despite not being able to figure out the splitInternalPage bug.


Division of Workload 
Chelsea completed exercises 1 and 2, which was implementing flushPage() and its helper methods, implementing the findLeafPage() method, and the skeleton methods in Predicate.java and IndexPredicate.java. Cameron completed exercise 3 which consisted of implementing BTreeFile.splitLeafPage() and BTreeFile.splitInternalPage().